# 문자열 덧셈 계산기 (javascript-calculator-precourse)


## 💡 왜 구현을 해야 하는가
첫 번째 과제는 문자열을 더하는 과제임. 이러한 문제로 내가 배울 수 있는 것은 무엇인지, 왜 하필 문자열을 더하는 것을 변환하여 연습하는 지가 궁금했음.

간단한 계산 문제 같지만, 개발자로서 성장하는데 배울 점이 있을 것이라는 생각과 함께 문제 파악을 시작함. 

이 과제의 핵심은 **문자열 형태로 입력된 숫자 데이터를 처리하는 법**을 연습하는 것임. 

보통 계산기는 숫자를 입력받아 계산한다고 생각함.  
도대체 **“어떤 경우에 이런 계산이 필요한지”** 궁금했음.

조사 결과, 실제 개발 환경에서 대부분의 외부 입력(사용자 입력, API, 파일 등)은  **문자열(String)** 형태로 전달되며, 이를 안전하게 **숫자로 변환하고 검증하는 과정**이 필요함. (예를 들어 쇼핑몰에서 금액을 서버로 보낼 때를 포함.)


## 💳 문제와 가장 비슷하다고 생각한 사례 - 계좌번호
예를 들어, 사용자가 `"110-234-567890"` 같은 **계좌번호**를 입력하면 시스템은 하이픈(`-`)을 제거하고 숫자만 남긴 뒤  
**유효성 검증** 등을 수행함.  
(출처: [Talkpal - 숫자에 대한 문자열](https://talkpal.ai/ko/grammar/%EC%88%AB%EC%9E%90%EC%97%90-%EB%8C%80%ED%95%9C-%EB%AC%B8%EC%9E%90%EC%97%B4/))

이처럼 입력은 **문자열로 들어오지만**,  실제 처리는 **숫자로 변환된 데이터**를 기반으로 이루어지는 경우가 있음.  따라서 문자열 덧셈 계산기는 이런 실제 상황을 단순화한 형태로  문자열 데이터를 **안전하게 파싱하고 계산하는 과정**을 연습하기 위한 과제라고 생각하며 진행함. 

주민등록번호를 검증 과정을 해당 과제에서 숫자를 더하는 것으로 가정하니 문제가 흥미로워지기 시작했음. (주민등록번호로 가정하고 시작한 만큼 코드 마지막에서 안정성을 올리는 법을 탐구해볼 것임.)

---

## ✅ 구현 체크리스트 (기능 단위)

### 1️.입력 처리
- [x] 사용자에게 문자열을 입력받는다. 
(→ @woowacourse/mission-utils의 Console.readLineAsync()로 사용자 입력 처리.→ 입력 안내 문구 출력 및 입력값 출력으로 흐름 확인.)

- [x] 입력이 **빈 문자열(`""`)**이면 `0`을 반환한다.  
  - 예: `"" → 0`
  (->trim()`으로 앞뒤 공백을 제거해 빈 입력 여부를 판단.)

### 2️.구분자 처리
- [x] **기본 구분자** `,`(쉼표), `:`(콜론)으로 분리한다.
(-> 쉼표(,)와 콜론(:)을 정규식 /[, :]/로 분리하여 토큰 배열 생성.)

- [x] **커스텀 구분자**가 있을 경우 `"//"`와 `"\n"` 사이의 **한 글자**를 구분자로 인식한다.  
(-> 정규식 /^\/\/(.)\s*(?:\r?\n|\\n)([\s\S]*)$/를 사용해 CRLF(\r\n) 및 리터럴 \n 모두 처리)

- [x] 커스텀 구분자가 있을 때만 위 규칙을 적용하고, 없으면 기본 구분자를 사용한다.

- [x] 구분자 사이에 값이 비어 있는 **잘못된 형식**(예: `"1,,2"`, `"//;\n1;;2"`)은 예외 처리한다.
(->split 결과의 빈 문자열을 검사하여 형식 오류 감지)

### 3.숫자 추출 및 검증
- [x] 분리된 토큰을 **정수로 변환**한다.
(->문자열로 분리된 각 토큰을 `Number.parseInt()`를 사용해 정수로 변환함.)

- [x] **양수만 허용**한다. (음수 불가)
(->Number.parseInt() 변환 후 num < 0 조건으로 음수 검증 추가)

- [x] 숫자가 아닌 값이 포함되면 예외 발생 
(->정규식 /^-?\\d+$/로 문자열이 순수 숫자인지 검증하도록 개선)


- [x] 변환할 수 없는 값(빈 문자열 등)이 있으면 예외 발생  (->기본 구분자 정규식을 `/[, :]/` → `/[,:]/` 로 변경하여 공백(` `)을 데이터로 인식하도록 수정.)

### 4.덧셈 계산
- [x] 검증된 **정수 배열의 합**을 계산한다.  
- [x] 계산 결과를 반환한다.
(->`parser.js`에서 입력 문자열을 토큰화하고, 각 값을 **정수로 변환 및 검증**하여 `add.js`로 전달-> `add.js`에서는 전달받은 **정수 배열(numbers)**을 `reduce()`를 사용해 합산.)


### 5.결과 출력
- [x] 계산 결과를 다음 형식으로 출력한다. 결과 : 6
- [x] 예외 발생 시 메시지는 **반드시 `[ERROR]`로 시작**한다.  
(-> 최종 예외 처리 목록 확인 완료)

---

## 🚨 예외 처리 목록

- [x] 1. 빈 구분자(연속된 구분자)  
   - 예: "1,,2", "//;\n1;;2"  
   - [ERROR] 잘못된 구분자 형식입니다.

- [x] 2. 음수 입력  
   - 예: "1,-2,3"  
   - [ERROR] 음수는 허용되지 않습니다.

- [x] 3. 숫자가 아닌 문자 포함  
   - 예: "1,a,3"  
   - [ERROR] 숫자만 입력 가능합니다.

- [x] 4. 변환 불가능한 값 포함  
   - 예: "1, ,3", "//;\n1;\n2"  
   - [ERROR] 변환할 수 없는 값이 있습니다.

   - 💡 헷갈린 부분 -> 공백은 데이터로 존재하므로 오류,
아무것도 없으면 입력이 없으므로 0.

- [x] 5. 커스텀 구분자 형식 오류  
   - 예: "//\n1;2"  
   - [ERROR] 커스텀 구분자 형식이 올바르지 않습니다.

---

## 추가 오류 발견 

### 숫자 사이 공백 입력시 오류 발생
1. 입력값 `"2 2"`에서 `[ERROR] 숫자만 입력 가능합니다.`가 발생함.  
   이는 숫자 검증 정규식(`/^-?\d+$/`)이 숫자 사이의 공백을 허용하지 않았기 때문임.  

2. 숫자 사이에 공백이 포함된 경우를 감지하는 정규식(`/\d\s+\d/`)을 추가함으로,  
   구분자(`,` 또는 `:`) 누락 상황을 명확히 구분할 수 있도록 개선함.  

3. 이제 `"2 2"` 입력 시  
   `[ERROR] 숫자 사이에 공백이 있습니다.`  
   메시지가 출력되어 사용자 피드백이 더욱 직관적으로 개선됨.

### 예외 재던지기 개선
1. 코드에서는 `catch` 블록에서 콘솔에만 출력하고 종료되어, 테스트 입장에서는 “에러가 발생하지 않은 것처럼” 인식되었음.

2. `throw new Error("[ERROR] " + error.message)` 형태로 예외를 재던지도록 수정함.
---

## 💭 코드 개선 고민 1 🤔
코드는 완성했으나, 처음에 **주민등록번호나 계좌번호** 처럼 “문자열 형태로 전달된 숫자를 얼마나 안전하게 다룰 수 있을까”에서 출발했던 만큼 코드의 안정성을 더 높이는 방법에 대해 고민하게 되었음.  

내가 주민등록번호 혹은 쇼핑몰의 돈을 검증하는 역할을 맡게 된다면 사소한 오류도 없게 해야 함.
그렇기에 자바스크립트에서 정밀도를 어디까지 검증할 수 있는 지 찾아보았음.

```
MDN Web Docs의 parseInt() 문서 확인 결과, 자바스크립트의 Number 타입은 정밀도를 2⁵³−1 (≈9,007,199,254,740,991)까지만 보장함. 

이를 초과한 정수 연산은 부동소수점 오차로 인해 정확한 결과를 낼 수 없음.

따라서 큰 수 연산에서는 Number.isSafeInteger()를 통해 검증하거나, 필요하면 BigInt를 써야 함.
(출처:[MDN Web Docs - parseInt()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt))

```

이 내용을 바탕으로 add.js를 다음과 같이 개선했음.

### add.js 개선 내용 
```
1. reduce() 대신 for...of문을 사용해 매 연산마다 안전 정수 범위를 검사하도록 바꿨음.

2. Number.isSafeInteger()로 누적값(acc)과 현재값(n), 그리고 합(acc + n)을 모두 확인하도록 함.
→ 안전 범위를 벗어나면 [ERROR] 안전한 정수 범위를 초과했습니다. 출력.

3. 이 검사를 통해, 2⁵³−1을 초과하는 큰 수 연산에서 발생할 수 있는 정밀도 손실 문제를 사전에 차단했음.
```

## 💭 코드 개선 고민 2 🤔
코드를 읽으며 어떤 상황에서 오류가 발생하고, 어떻게 해결해야 하는지를 계속 고민했음.
하지만 ERROR 메시지가 흩어져 있어, 어떤 오류를 이미 검증했고 어떤 것이 누락되었는지 한눈에 파악하기 어려웠음.

또한, 내가 발견하지 못한 새로운 오류가 발생했을 때,
“이 오류가 이미 정의되어 있는지”를 즉시 확인할 수 있다면 훨씬 효율적일 것이라 생각함.

특히 주민등록번호나 계좌번호처럼 입력 검증이 필요한 시스템에서는
운영자 등 비개발자도 오류 원인을 빠르게 이해해야 하는 경우가 있음. 이런 UX 관점을 고려하여, 모든 오류 메시지를 한 곳(errors.js)에 모아 관리하도록 수정함.

### error.js 개선 내용
```
1. 오류 상수 정의 파일 추가 (errors.js)
-> 모든 Error 메시지를 상수로 분리하여 중앙 관리.

2. 기존 코드의 throw 구문 수정
-> 각 파일에서 직접 문자열을 던지는 대신, errors.js 상수를 참조하도록 변경.

3. 에러 정의 일원화
-> 동일한 문구, 중복된 메시지를 정리하여 일관된 오류 정책 수립.
```
---

## 개발을 마무리하며 
코드를 짜다 보니 단순히 기능을 구현하는 것 이상의 생각들이 떠올랐음. 그래서 이 경험을 세 가지 관점으로 정리해보았음.

- **개발자의 관점에서의 생각** 
-> 처음에는 단순한 문자열 합산 문제라고 생각했지만,
막상 구현을 시작하니 예상치 못한 부분에서 계속 막혔음.
예를 들어 정규식 하나를 잘못 쓰면 커스텀 구분자가 제대로 작동하지 않았고, 입력값에 공백이 하나만 있어도 전혀 다른 오류가 발생했음. 이 과정을 통해 예외 처리와 입력 검증의 중요성을 실감하게 되었음.

- **UX 관점에서의 생각** 
-> 현재는 최종 결과값(예: 결과 : 6)만 출력되지만,
사용자가 입력한 데이터(1,2,3)가 어떻게 처리되어 합산되었는지를
시각적으로 함께 보여주는 것도 좋을 것 같았음.
예를 들어, “입력값 [1, 2, 3] → 합계 6”처럼 파싱된 토큰을 함께 노출하면 사용자가 “내 입력이 제대로 인식됐구나”라는 신뢰를 얻을 수 있고,디버깅 과정에서도 직관적인 피드백이 가능하다고 생각했음.

- **기획자 관점에서의 생각**
-> 해당 개발이 어디에 응용이 될 수 있을 지 생각하다가 영수증에 적힌 금액 문자열을 자동으로 인식해 합산해주는 앱, 또는 카메라 OCR과 결합해 사진 속 금액을 추출·계산하는 기능으로
확장하면 좋겠다는 생각이 들었음. 이렇게 하면 금액을 직접 입력하기 어렵거나 귀찮음을 느끼는 사람들도 보다 쉽게 가계부를 작성하거나 지출을 관리할 수 있을 것이라는 아이디어가 떠올랐음.
